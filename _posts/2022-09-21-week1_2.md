---
toc: true
layout: post
description: 부스트캠프 3일차 공부 정리.
image : images/220127.png
categories: [BoostCamp, math, Moore-Penrose, Monte Carlo, MLE, KL Divergence, markdown]
title: "[BoostCamp]Day3 파이썬"
---
# 3일차 공부 정리 (업데이트중)
## 파이썬 리스트

![리스트](https://softvanilla.github.io/assets/images/python/5/listinlist.png)

리스트 내 어떤 데이터 타입이든 들어갈 수 있습니다. 그림과 같이 리스트의 원소로 리스트가 들어갈 수도 있습니다.

이게 가능한 이유는 리스트 변수에는 리스트 주소값이 저장되기 때문입니다. 그러므로 형식이 자유로워 집니다.

~~~ python
a = [5,4,3,2,1]
b = [1,2,3,4,5]
b = a

# 같은 리스트 값을 복제하는 방식으로 b에 할당하고 싶을때
b = a[:] 
~~~

![리스트2](https://user-images.githubusercontent.com/79916736/191219321-665e42fe-1f36-4f46-8471-620cc290a4bd.png)

다음 코드를 실행하게 되면(b = a) 컴퓨터 내부적으로 윗 그림과 같은 일이 벌어집니다. 두 변수 모두 서로 같은 리스트를 가리키게 되죠.

변수는 리스트를 입력받을 때 리스트의 주소 값을 할당하는 방식으로 입력받기 때문입니다.

같은 리스트를 할당하지 않고, 리스트를 복제하여 할당하고 싶을 때는 밑 코드(b = a[:])을 실행해야 합니다.

~~~ python
import copy

kor_score = [49, 79, 20, 100, 80]
math_score = [43, 59, 85, 30, 90]
eng_score = [49, 79, 48, 60, 100]
midterm_score = [kor_score, math_score, eng_score]

# 아래 식은 복제가 되지 않음. (일차원 리스트와 다릅니다.)
# midterm_copy = midterm_score[:]
# copy 패키지 내 deepcopy를 사용해야함.
midterm_copy = copy.deepcopy(midterm_score)
~~~

이차원 리스트는 일차원 리스트와 또 다르게 복제하려면 위와 같이 다른 방법을 사용해야 합니다.


## 파이썬 함수

### Call by Reference

파이썬 함수 호출 방식은 'Call by Reference' 입니다. 함수에 인자를 넘길 때 메모리 주소를 넘기고, 함수 내에 인자 값 변경 시 호출자의 값도 변경됩니다.

이 사실을 잘 모르고 있다면 함수를 사용한 코드를 디버깅 할 때 혼란스러울 수 있습니다.

개인적으로 예전에 코딩테스트 시험를 볼 때 함수를 거친 것 뿐인데 값이 도대체 왜 바뀌는 지에 대한 의문이 풀립니다.

~~~ python
def spam(eggs): # 인자로 넘어온 주소값을 eggs에 넣음.
    eggs.append(1) # 기존 객체의 주소 값에 [1] 추가.
    eggs = [2,3] # 새로운 객체 생성.

ham = [0]
spam(ham)
print(ham)  # 결과 : [0, 1]
# ham 값이 spam 함수를 거치니 달라졌음.
~~~

'함수에 인자를 넘길 때 메모리 주소를 넘기고, 함수 내에 인자 값 변경 시 호출자의 값도 변경됩니다.' 를 잘 보여주는 예시 코드 입니다.

### 스와핑

~~~ python
def swap_value(x, y):
    temp = x
    x = y
    y = temp

def swap_reference(list_ex, offset_x, offset_y):
    temp = list_ex[offset_x]
    list_ex[offset_x] = list_ex[offset_y]
    list_ex[offset_y] = temp

ex = [1,2,3,4,5]
swap_value(ex[0], ex[1])
print(ex) # [1,2,3,4,5], 리스트 값이 안 바뀐다.
swap_reference(ex, 0,1)
print(ex) # [2,1,3,4,5], 리스트 값이 바뀐다.
~~~

윗 함수는 변수 스와핑이 일어나지 않고 아랫 함수는 변수 스와핑이 일어납니다. 리스트 내 변수 스와핑을 할 때 유의해야 합니다.

또 참고할 점은 파이썬에서 연산 속도를 위해 자주쓰는 -5~256 까지의 숫자의 주소 값은 미리 할당했다는 것을 기억하면 좋겠습니다.

### 지역변수, 전역변수

다음으로 함수 내 변수를 새로 선언하면 지역변수로써 그 함수 내에서만 사용이 가능합니다. 함수 바깥에 있는 변수는 전역변수로써 함수에서도 차용해서 사용이 가능하구요.

다만 함수 내에 전역변수와 이름이 같은 변수를 선언하면 새로운 지역 변수가 생깁니다.

만약 함수 내에서 전역변수로 사용하고 싶다면 global 키워드를 이용하면 좋겠습니다.

~~~ python
def f():
    global s
    s = 'I love Hanam!'
    print(s) # 'I love Hanam!'

s = 'I love Seoul!'
print(s) # 'I love Seoul!'
f()
print(s) # 'I love Hanam!'
~~~

### 가변인자

개수가 정해지지 않는 변수를 함수의 파라미터로 사용할 때 사용합니다.

Asterisk(*) 기호를 사용하고 가변인자는 맨 마지막 파라미터 위치에서 한 개만 사용 가능합니다. 그리고 입력된 값은 튜플로 사용됩니다.

또 Asterisk(*) 기호를 2개 사용하는 키워드 가변인자도 존재합니다. 입력 값은 dict 타입을 사용해야합니다.

~~~python
def asterisk_test(a, b, *args):
    return a+b+sum(args)

def kwargs_test_3(one,two, *args, **kwargs):
    print(one+two+sum(args))
    print(kwargs)

print(asterisk_test(1, 2, 3, 4, 5))
kwargs_test_3(3,4,5,6,7,8,9, first=3, second=4, third=5)
~~~

### 일등함수

파이썬의 함수는 일등함수 입니다. 일등함수란 변수나 데이터 구조에 할당이 가능한 객체이고, 파라미터로 전달이 가능하며 리턴 값으로도 사용할 수 있어야 합니다.

개인적으로 이전에 R을 배웠었는데 R과 작동 원리가 똑같은 것 같습니다.

일등함수 성질을 사용하면 다음과 같은 응용이 가능합니다.

~~~python
def print_msg(msg):
    def printer():
        print(msg)
    return printer

another = print_msg("Hello, Python")
another() # another 함수는 'Hello, Python'을 프린트 해주는 함수.
# 위와 같이 함수를 찍어내는 함수를 만들 수 있음. 이를 클로저 라고 함.
~~~

## 파이썬 내 알아두면 좋을 것들

### docstring

docstring 이란? 함수에 대한 상세스펙을 함수명 아래에 작성하는 것 입니다.

vscode 내 docstring 을 설치하고 명령창에 docstring을 쓰면 쉽게 사용 가능합니다.

![docstring](https://i.stack.imgur.com/EE8MB.png)

### 코딩 컨벤션

협업을 진행할 때 쉽게 이해하도록 개인의 코딩 습관을 자제하고, 정해진 코딩 규칙을 지키는 것 입니다.

일반적인 코딩 규칙으로

* 들어쓰기 4칸
* 한 줄은 최대 79자(화면 크기가 작은 사람 배려)
* 불필요한 공백은 피함
* 코드 마지막엔 항상 한 줄 추가
  
등이 있습니다.

참고로 파이썬 내 black 모듈을 사용하면 pep8 like 라는 수준을 준수하는 코드로 자동 변경 되니 협업 하는 경우 한번 돌리고 사용해도 좋을 것 같네요.
