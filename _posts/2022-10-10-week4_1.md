---
toc: true
layout: post
description: 부스트캠프 16일차 공부 정리.
image : images/221010.PNG
categories: [BoostCamp, DeepLearning, Recommender system, TF-IDF, Basic]
title: "[BoostCamp]Day16 추천시스템 Basic"
search_exclude: false
---
# 16일차 공부 정리

## 간단한 추천시스템 개요

추천시스템 자체는 상당히 오래된 개념입니다. 단순하게 사람에게 item을 추천하는 것이 추천시스템이니깐요.

최근 추천시스템이 주목을 받는 이유로는 여러가지 설명을 해주셨지만 그 중 가장 인상깊었던 것이 'Long Tail Phenomenon' 입니다.

벌써 오래됬지만 인터넷 환경이 발달해 정보량이 거대해졌는데요.

![Long Tail Phenomenon](https://user-images.githubusercontent.com/79916736/194872166-8e0da643-e8bc-4f79-b160-10b720c96c56.png)

위 그래프를 해석하면 소수의 item이 극단적으로 높은 인기도를 가지고, 대부분의 item은 인기도가 많이 떨어짐을 알 수 있습니다.

Long Tail Phenomenon 부분에 존재하는 item을 적합한 사용자에게 잘 추천해 줄 수 있다면 엄청난 부가가치가 나올 것 입니다.

이와같은 추천 시스템 모델의 품질을 측정하는 기준을 정리해보겠습니다.

- 연관성 : 추천된 아이템이 사용자에게 관련이 있는가? (당연하죠.)
- 다양성 : 얼마나 다양한 아이템이 사용자에게 추천되는가? (대중적으로 최고인 것만 추천하는 것 방지)
- 새로움 : 얼마나 새로운 아이템이 추천되는가? (위 그래프와 직접적인 연관)
- 참신함 : 사용자가 기대 못한 뜻밖에 아이템이 추천되는가? (연관성과 다소 충돌될 수 있습니다.)

또, 앞으로 추천시스템을 배우게 될 때 머신러닝 모델을 꽤 많이 접하게 될 것입니다. 이유로는

- CV/NLP 대비 추천시스템은 딥러닝 성능이 압도적이지 못함
- 딥러닝 모델은 무거운데 추천시스템은 이를 처리하기에 부담이 큼

이 있습니다.

## 추천시스템 모델 평가 과정

먼저 Online/Offline Test 부터 구분합니다. 

Offline Test는 새로운 추천 모델을 검증하기 위해 가장 먼저 수행되는 단계입니다.

일반적인 모델 검증 방법과 비슷하게 수집된 데이터를 train/valid/test로 나눈 뒤 성능을 객관적인 지표로 평가합니다.

이에 반해 Online Test는 Offline Test에서 검증된 모델을 이용해 실제 추천 결과를 서빙하는 단계입니다.

이 때 시점에 따라 모델 성능이 바뀔 수 있기 때문에 추천 시스템 변경 전후의 성능을 비교하지 않고, 동시에 대조군과 실험군의 성능을 평가하여 모델 성능을 평가합니다.

현업에서 의사결정에 사용하는 Online Test에서의 최종 지표는 모델 성능이 아닌 매출, CTR 등 비지니스 지표입니다.

## Offline Test

그렇다면 Offline Test에서 추천시스템 모델을 평가하는데는 어떤 성능 지표를 사용할지 알아봅시다.

### Precision@K

우리가 추천한 K개의 아이템 가운데 실제 유저가 관심있는 아이템의 비율입니다. 심플하게 얼마나 정확한가, 무분별하게 막 찍지는 않았나를 파악합니다.

Precision@K = (K개중 맞춘 개수) / K

### Recall@K

사용자가 관심있는 전체 아이템 중 우리가 추천한 아이템의 비율 입니다. 심플하게 얼마나 찾아냈냐이죠.

Recall@K = (K개중 맞춘 개수) / (사용자가 관심있는 아이템의 전체 개수)

### AP@K

![AP@K](https://user-images.githubusercontent.com/79916736/195042622-525cce8a-cccb-48b8-a233-7ebba98e8cc4.png)


Precision@1 부터 Precision@K 까지의 평균값입니다. 정답인 아이템을 더 앞서서 잘 추천한다면 값이 커지겠죠.

### MAP@K

![MAP@K](https://user-images.githubusercontent.com/79916736/195044650-912cccec-361d-461c-961e-d96d27a7e87d.png)

모든 사용자에 대한 AP@K값의 평균입니다. 추천시스템 모델이 대략적으로 어떤지 파악이 가능하겠군요.

### NDCG@K

이상적인 추천이 일어났을 때 대비 실제 추천을 할 때가 얼마나 차이나는지를 나타내는 지표 입니다.

식은 $DCG = \sum_{i=1}^{K}\frac{rel_i}{log_{2}{(i+1)}}$ 입니다. 이 때 rel는 i번째 추천된 아이템의 상대적 수치로 앞선 지표들과 달리 이진 값이 아닌 수치로 연관성을 표현할 수 있다는 특징이 있습니다. 간단한 NDCG@K의 예시입니다.

![NDCG@K](https://user-images.githubusercontent.com/79916736/195048134-2d0b80b7-373c-4f03-9528-4da6c6abe4d1.png)

## 인기도 기반 추천

가장 단순하면서도 강력한 추천시스템 모델로 인기도 기반 추천 모델이 있습니다.

조회 수가 가장 많은 아이템 혹은 평균 평점이 가장 높은 아이템을 추천하는 것이 방법이 되겠습니다.

이 때 조회 수는 기간이 길 수록 상승하기 쉽고, 사람들은 새로운 아이템을 원하는 성향이 있기 때문에(뉴스 등) 얼마나 최근에 나온 아이템인지도 중요합니다.

다음으로 평균 평점도 신뢰할 수 있을만큼 평가의 개수가 충분한지를 따지는 것이 중요합니다.

즉 아이템을 추천하기 위해 인기도를 score로 만든다면 앞서 말한 요소를 모두 고려해야 합니다.

![Hacker News Formula](https://user-images.githubusercontent.com/79916736/195049746-ca9a8546-b98c-4d71-bdf5-a78ca7b819fc.png)

예시로 Hacker News에서 score를 구하는 공식 입니다. 보통 gravity는 1.8을 사용하구요. 기간이 오래될수록 스코어 값이 떨어지는 것은 당연한데 지수적으로 떨어지기 때문에 기간이 오래된 경우 아무리 pageviews가 높더라도 score을 유지하기 힘들겠죠.

![movie](https://user-images.githubusercontent.com/79916736/195050727-bec3563b-abce-4c22-b694-c3d5b2f4ac7e.png)

다음으로 영화 평점 score입니다. 리뷰의 수가 많을 수록 평점 자체의 신빙성을 올려주는 방식이네요.

## 연관 규칙

장바구니 분석이라고도 하며 상품의 연속된 거래들 사이의 규칙을 발견하기 위해 적용합니다. (맥주와 기저귀를 같이 구매하는 빈도?)

먼저 정의할 것은 itemset으로 1개 이상의 item의 집합인데 하나의 상품이 등장했을 때 다른 상품이 같이 등장한 경우를 나타냅니다.

이 itemset을 이용해 item 사이의 연관도를 나타내는데 구체적으로 support는 전체 데이터에 대한 itemset의 확률 값 입니다.

다음으로 confidence는 Y의 X에 대한 조건부 확률로 식은 다음과 같습니다. (X와 Y가 동시에 포함된 개수 / X 개수, X와Y는 itemset임)

$c(X\xrightarrow{}Y) = \frac{n(X\cup Y)}{n(X)} =P(Y\mid X)$

다만 confidence는 너무 적게 사는 item에 경우 보정이 미흡하기 때문에 이를 극복하기 위해 lift를 사용합니다.

(맥주와 맥주 따게는 분명 같이 구매하는 경우가 많습니다. 그리고 맥주와 기저기도 구매하는 경우가 많죠. 우리는 직관적으로 맥주 따게가 더 맥주와 연관성이 깊다는 사실을 알고 있습니다. 하지만 기저기 대비 맥주 따게의 절대적인 판매량 자체가 매우 작기 때문에 confidence는 맥주 따게가 높지 않을 수도 있습니다. 기저기는 맥주를 구매하지 않더라도 판매량이 높지만 맥주 따게는 맥주를 사지 않는 경우 거의 판매가 되지 않는 경우인 데도 말이죠.)

$l(X\xrightarrow{}Y) = \frac{n(X\cup Y)}{n(X)n(Y)}$

lift는 confidence에서 n(Y)로 나눠주었기 때문에 위에서 설명한 맥주 따게 같은 경우 기저기 대비 n(Y)값이 매우 작게 되겠죠. 즉 lift 값은 꽤 큰 값이 나오게 될 것입니다.

lift는 상관관계로도 해석될 수 있는데, lift = 1이면 X와Y는 독립, lift > 1 인 경우 X와 Y가 양의 상관관계를 갖게 되는데 이는 두 itemset이 연관성이 큼을 나타냅니다.

![itemset](https://user-images.githubusercontent.com/79916736/195079847-0f97f746-f7e0-443a-9be5-bfb0aa104eee.png)

연관 규칙를 파악하는 측도 support, confidence, lift를 구하는 간단한 예시 입니다.

하지만 Item의 수가 많아질수록 연산량이 기하급수적으로 많아지게 됩니다.

이를 효율적으로 하기 위해서 minimum support, minimum confidence을 정해서 이 값보다 낮은 값을 등장하는 빈도가 낮아 분석 가치가 떨어진다고 판단, 지워버림으로써 보다 연산량을 효율적으로 할 수 있습니다.

다만 support, confidence를 구하는 것 부터 힘든 작업입니다. 이를 Brute-force 형식으로 진행하면 큰 무리가 따릅니다. 이를 극복하기 위해 다양한 알고리즘을 사용하는데 그 중 itemset 개수를 줄여주는 Apriori 알고리즘을 추후에 공부해보겠습니다.

(Brute-force는 고유의 아이템 개수에 2의 지수승 만큼 시간복잡도가 생깁니다.)

## TF-IDF를 활용한 컨텐츠 기반 추천

컨텐츠 기반 추천이란 기본적으로 사용자를 분석해 과거에 선호한 아이템과 비슷한 아이템을 추천합니다.

이 때 비슷한 아이템이라 함은 아이템의 성질을 찾아서 수학적으로 표현해야 한다는 숙제가 있는데, 사용하려는 분야마다 조금씩 차이가 있습니다.

이 방식은 다른 유저의 데이터를 이용하지 않고, 인기도가 낮은 아이템도 추천이 가능하며 왜 추천했는지에 대한 설명도 어느정도 가능합니다. 다만 한 분야의 추천 결과만 계속 나올 수 있는 단점이 존재합니다.

아이템의 성질로 자주 사용하는 것이 문서 내 단어들 입니다. 이 때 TF-IDF 방식을 이용하게 됩니다.

TF-IDF란 Term Frequency – Inverse Document Frequency로 본 문서에는 자주 등장하는지, 전체 문서에 적게 등장하는지에 따라 값이 커지는 지표입니다. 이 지표가 큰 경우 해당 단어가 문서를 설명하는 중요한 피처라는 것을 보여주겠죠?

![TF-IDF1](https://user-images.githubusercontent.com/79916736/195084968-c78972a2-a797-427a-9b29-ddb06fc5cbaa.png)
![TF-IDF2](https://user-images.githubusercontent.com/79916736/195085017-4404748d-764f-42a8-8fd0-9c6fccbc2575.png)
![TF-IDF3](https://user-images.githubusercontent.com/79916736/195085067-2570aeec-a370-43d6-91da-3d2b8345e927.png)

실제 수식은 다음과 같습니다. freq(w,d)는 현재 문서d에 w단어가 몇번 들어갔는지, N은 전체 문서 개수, N(w)는 w단어가 등장한 문서 개수를 의미합니다. TF는 문서 단위로 정규화를 진행하기도 하며 IDF는 값의 변화가 크기 때문에 log-스케일을 적용한 모습입니다.

![TF-IDF4](https://user-images.githubusercontent.com/79916736/195085631-926ff8f5-2fe4-493c-801b-ddad428f7ffc.png)

다음 값을 예시로 생각했을 때 TF-IDF 값을 계산하여 문서별로 벡터를 만들면

![TF-IDF5](https://user-images.githubusercontent.com/79916736/195085769-4fe21529-b2bb-4329-86c2-f5b7f4e09e8e.png)

다음과 같은 결과가 나오게 됩니다. 여기서 천천히 생각해봅시다. 사용자는 현재 d1, d2, d3, d4의 item list로 가지고 있는 겁니다. 우리가 한 작업은 item list를 수치화 시켜 표현한 일이죠. 벡터 값을 잘 조합한다면 User Profile로 생각할 수 있지 않을까요?

이렇게 구한 User Profile(item list 내 벡터들을 단순 평균내거나 랭킹에 따른 가중평균을 냄)을 바탕으로 이와 비슷한 아이템을 추천하게 됩니다.

이 때 '비슷'하다고 판단하는 기준에는 여러가지가 있는데 코사인 유사도를 주로 사용한다고 합니다.

혹은 이런 작업도 가능합니다.

![movie2](https://user-images.githubusercontent.com/79916736/195087557-569f3d76-75ee-4e22-b243-be7b3f73b1e5.png)

1,2,3번 영화(item)에 정보를 품고 있는 v벡터를 구축합니다. 또 사용자는 1,2,3번 영화에 대한 평점을 가지고 있죠.

이때 4번 영화의 평점을 예측하기 위해선 1,2,3번 영화와 얼마나 유사한지를 구한 뒤 이를 가중평균을 취해 4번 영화의 예측값을 구하게 됩니다. 가중평균을 사용할 땐 코사인 유사도를 사용하구요.

## 느낀점

정리하니깐 정말 긴 내용이라는 것이 체감됩니다. 그래도 뿌듯하군요.

휴일이지만 못 즐겼네요. 아직 초반이지만 많이 고됩니다..

조금만 더 힘내서 이번주도 잘 버텨봅시다. 화이팅!

** 위 수식과 그림은 부스트캠프 AI Tech 교육 자료를 참고하였습니다.